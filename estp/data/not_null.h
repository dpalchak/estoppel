#pragma once

#include "estp/base/types.h"
#include "estp/base/meta.h"

#include <memory>
#include <type_traits>
#include <utility>

// Implementation of non-null pointer as described in the C++ GSL

namespace estp {

template<typename T>
class NotNull {
public:
    static_assert(std::is_assignable<T&, std::nullptr_t>::value, "Invalid type for NotNull<T>");

    // Most pointer-like types T are low-cost movable
    constexpr explicit NotNull(T t) : _ptr{std::move(t)} {
        EXPECTS(_ptr != nullptr);
    }

    template<typename U, typename = EnableIf< IsConvertible<U,T> > >
    constexpr NotNull(NotNull<U> const &other) : _ptr{other.get()} {}

    constexpr T get() const {
    	// Rely on return value optimization for non-trivial types
        return _ptr;
    }

	constexpr operator T() const { return get(); }
	constexpr T operator->() const { return get(); }
	constexpr decltype(auto) operator*() const { return *get(); }

    // Explicitly disable construction or assignment from nullptr
    NotNull(std::nullptr_t) = delete;
    NotNull& operator=(std::nullptr_t) = delete;

    // Explicitly delete manipulation operators
    // None of these are generated by default, but we don't want the compiler to implicitly
    // convert to a standard raw pointer and then manipulate the value
    NotNull& operator++() = delete;
    NotNull& operator--() = delete;
    NotNull operator++(int) = delete;
    NotNull operator--(int) = delete;
    NotNull& operator+(std::size_t) = delete;
    NotNull& operator+=(std::size_t) = delete;
    NotNull& operator+=(std::ptrdiff_t) = delete;
    NotNull& operator-(std::size_t) = delete;
    NotNull& operator-=(std::size_t) = delete;
    NotNull& operator-=(std::ptrdiff_t) = delete;
    void operator[](std::ptrdiff_t) const = delete;

private:
    T _ptr;
};

// Explicitly delete non-member operator overloads
template<typename T, typename U>
std::ptrdiff_t operator-(NotNull<T> const&, NotNull<U> const&) = delete;

template<typename T>
NotNull<T> operator-(NotNull<T> const&, std::ptrdiff_t) = delete;

template<typename T>
NotNull<T> operator+(NotNull<T> const&, std::ptrdiff_t) = delete;

template<typename T>
NotNull<T> operator+(std::ptrdiff_t, NotNull<T> const&) = delete;

// Allow strongly ordered comparisons between non_null types
template<typename T, typename U>
constexpr bool operator==(NotNull<T> const &lhs, NotNull<U> const &rhs) {
	return lhs.get() == rhs.get();
}

template<typename T, typename U>
constexpr bool operator!=(NotNull<U> const &lhs, NotNull<U> const &rhs) {
	return lhs.get() != rhs.get();
}

template<typename T, typename U>
constexpr bool operator<(NotNull<U> const &lhs, NotNull<U> const &rhs) {
	return lhs.get() < rhs.get();
}

template<typename T, typename U>
constexpr bool operator<=(NotNull<U> const &lhs, NotNull<U> const &rhs) {
	return lhs.get() <= rhs.get();
}

template<typename T, typename U>
constexpr bool operator>(NotNull<U> const &lhs, NotNull<U> const &rhs) {
	return lhs.get() > rhs.get();
}

template<typename T, typename U>
constexpr bool operator>=(NotNull<U> const &lhs, NotNull<U> const &rhs) {
	return lhs.get() >= rhs.get();
}

}
