<!DOCTYPE html>
<html>

  <head>
    <title>Projects Overview</title>
    <style>
      .descriptionColumn { min-width:550px;}
      em{color:red;font-weight: bold;}
      importantLink {font-size:10pt; font-family: "Verdana","sans-serif" color:black;}
      article{border: 1px solid #828282;margin: 20px 0px 20px 9px;}
      body{font-family: Verdana;font-size: 10pt; color: black;margin-left: 40px;}
      .picture{text-align: center}
      .copyright{text-align: center}
      h1{text-align: center;font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);}
    </style>
  </head>
  <body>

    <h1>STM32CubeL4 Firmware Examples for STM32L4 Series and STM32L4+ Series</h1>

    <p class="copyright">Copyright 2017 STMicroelectronics</p>

    <div class="picture">
      <img alt="" id="_x0000_i1025" src="../_htmresc/st_logo.png" style="border: 0px solid ; width: 104px; height: 77px;"/>
    </div>

    <p>The STM32CubeL4 Firmware package comes with a rich set of examples running on STMicroelectronics boards, organized by board and provided with preconfigured projects for the main supported toolchains.</p>

    <div class="picture">
      <img alt="" src="../_htmresc/STM32Cube.bmp" style="width: 727px; height: 382px;"/>
    </div>

    <p>The examples are classified depending on the STM32Cube level they apply to, and are named as follows:</p>

    <ul>
      <li id="Examples"><b>Examples</b> uses only the HAL and BSP drivers (Middleware not used), having as objective to demonstrate the product/peripherals features and usage. The examples are organized per peripheral (a folder for each peripheral, ex. TIM) and offers different complexity level from basic usage of a given peripheral (ex. PWM generation using timer) till integration of several peripherals(use DAC for signals generation with synchronization from TIM6 and DMA). Board resources usage is reduced to the strict minimum.</li>
      <li id="Examples_LL"><b>Examples_LL</b> uses only the LL drivers (HAL and Middleware not used), offering optimum implementation of typical use cases of the peripheral features and configuration procedures. The examples are organized per peripheral (a folder for each peripheral, ex. TIM) and runs exclusively on Nucleo board.</li>
      <li id="Examples_MIX"><b>Examples_MIX</b> uses only HAL, BSP and LL drivers (Middleware are not used), having as objective to demonstrate how to use both HAL and LL APIs in the same application, to combine the advantages of both APIs (HAL offers high level and functionalities oriented APIs, with high portability level and hide product or IPs complexity to end user. While LL offers low level APIs at registers level with better optimization). The examples are organized per peripheral (a folder for each peripheral, ex. TIM) and runs exclusively on Nucleo board.</li>
      <li id="Applications"><b>Applications</b> intends to demonstrate the product performance and how to use the different Middleware stacks available. The Applications are organized per Middleware (a folder for each Middleware, ex. USB Host) or product feature that need high level firmware bricks (ex. Audio). Integration Applications that use several Middleware stacks are provided as well.</li>
      <li id="Demonstrations"><b>Demonstrations</b> aims to integrate and run the maximum of peripherals and Middleware stacks to showcase the product features and performance.</li>
      <li>A Template project is provided to allow user to quickly build any firmware application on a given board.</li>
    </ul>

    <p>The examples are located under STM32Cube_FW_STM32CubeL4_VX.Y.Z\Projects\, and all of them have the same structure:</p>

    <ul>
      <li>\Inc folder that contains all header files.</li>
      <li>\Src folder for the sources code.</li>
      <li>\EWARM, \MDK-ARM, \SW4STM32 and \TrueSTUDIO folders contain the preconfigured project for each toolchain.</li>
      <li>readme.txt describing the example behavior and the environment required to run the example.</li>
    </ul>

    <p>To run the example, you have to do the following:</p>

    <ul>
      <li>Open the example using your preferred toolchain.</li>
      <li>Rebuild all files and load the image into target memory.</li>
      <li>Run the example by following the readme.txt instructions.</li>
      <li>
        <i><u>Note</u>: refer to section "Development Toolchains and Compilers" and "Supported Devices and EVAL boards" of the Firmware package release notes to know about the SW/HW environment used for the Firmware development and validation. The correct operation of the provided examples is not guaranteed on some environments, for example when using different compiler or board versions.</i>
      </li>
    </ul>

    <p>The provided examples can be tailored to run on any compatible hardware; user simply need to update the BSP drivers for his board, if it has the same hardware functions (LED, LCD display, pushbuttons...etc.). The BSP is based on a modular architecture that allows it to be ported easily to any hardware by just implementing the low level routines.</p>

    <p>The table below contains the list of examples provided within STM32CubeL4 Firmware package.</p>

    <p id="STM32L4xxImportantLink">
      <div>Reference materials available on <a href="http://www.st.com/stm32cubefw" target="_blank">www.st.com/stm32cubefw</a></div>
      <ul>
        <li><a href="http://www.st.com/stm32cubefw" target="_blank">Latest release</a> of STM32CubeL4 Firmware package.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00157440.pdf" target="_blank">UM1860</a>: Getting started with the STM32CubeL4 firmware package for STM32L4 Series and STM32L4+ Series.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00173145.pdf" target="_blank">UM1884</a>: Description of STM32L4xx HAL drivers.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00105256.pdf" target="_blank">UM1720</a>: STM32Cube USB Host library.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00108129.pdf" target="_blank">UM1734</a>: STM32Cube USB Device library.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00105259.pdf" target="_blank">UM1721</a>: Developing Applications on STM32Cube with FatFs.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00105262.pdf" target="_blank">UM1722</a>: Developing Applications on STM32Cube with RTOS.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00211709.pdf" target="_blank">UM1916</a>: STM32CubeL4 Nucleo demonstration firmware.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00213619.pdf" target="_blank">UM1919</a>: STM32CubeL4 Demonstration firmware for 32L476GDISCOVERY discovery kit.</li>
        <li><a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/user_manual/DM00222162.pdf" target="_blank">UM1937</a>: STM32CubeL4 Demonstration firmware for STM32L476G-EVAL board.</li>
      </ul>
    </p>
		<table border='1' bgcolor='#f0f0fF' >
			<tr align=center style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;">
				<td><b>Level</b></td>
				<td><b>Module Name</b></td>
				<td><b>Project Name</b></td>
				<td class="descriptionColumn"><b>Description</b></td>
				<td>NUCLEO-L452RE-P</td>
				<td>NUCLEO-L4R5ZI</td>
				<td>STM32L476G-EVAL</td>
				<td>NUCLEO-L432KC</td>
				<td>NUCLEO-L452RE</td>
				<td>32L476GDISCOVERY</td>
				<td>B-L475E-IOT01A</td>
				<td>NUCLEO-L496ZG</td>
				<td>NUCLEO-L433RC-P</td>
				<td>NUCLEO-L476RG</td>
				<td>STM32L4R9I-EVAL</td>
				<td>NUCLEO-L4R5ZI-P</td>
				<td>NUCLEO-L496ZG-P</td>
				<td>32L4R9IDISCOVERY</td>
				<td>32L496GDISCOVERY</td>
			</tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=2><p id="Templates">Templates</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="Starter project">Starter project</p></td>
        <td align=left>
This project provides a reference template based on the STM32Cube HAL API that can be used
to build any firmware application.
</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of templates: 15</b></td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=2><p id="Templates_LL">Templates_LL</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="Starter project">Starter project</p></td>
        <td align=left>
This project provides a reference template based on the STM32Cube LL API that can be used
to build any firmware application.
</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of templates_ll: 15</b></td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=158><p id="Examples">Examples</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="BSP">BSP</p></td>
        <td align=left>
This example provides a description of how to use the different BSP drivers of the 
STM32L4R9I-EVAL board. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=9><p id="ADC">ADC</p></td>
        <td align=left><p id="ADC_AnalogWatchdog">ADC_AnalogWatchdog</p></td>
        <td align=left>
This example provides a short description of how to use the ADC peripheral to
perform conversions with analog watchdog and out-of-window interruptions enabled.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_DMA_Transfer">ADC_DMA_Transfer</p></td>
        <td align=left>
This example describes how to configure and use the ADC to convert an external
analog input and get the result using a DMA transfer, through the HAL API.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_DualModeInterleaved">ADC_DualModeInterleaved</p></td>
        <td align=left>
This example provides a short description of how to use two ADC peripherals to
perform conversions in interleaved dual-mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_LowPower">ADC_LowPower</p></td>
        <td align=left>
This example provides a short description of how to use the ADC peripheral to
perform conversions in ADC low-power auto-wait mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_OverSampler">ADC_OverSampler</p></td>
        <td align=left>
This example describes how to configure and use the ADC to convert an external
analog input combined with oversampling feature to increase resolution through the HAL API.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_RegularConversion_Interrupt">ADC_RegularConversion_Interrupt</p></td>
        <td align=left>
This example describes how to use the ADC in interrupt mode to convert data through the HAL API.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_RegularConversion_Polling">ADC_RegularConversion_Polling</p></td>
        <td align=left>
This example describes how to use the ADC in Polling mode to convert data through the HAL API.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_Regular_injected_groups">ADC_Regular_injected_groups</p></td>
        <td align=left>
This example provides a description of how to use the ADC peripheral to
perform conversions using the two ADC groups: regular group for ADC conversions
on main stream and injected group for ADC conversions limited on specific events
(conversions injected within main conversions stream).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_Sequencer">ADC_Sequencer</p></td>
        <td align=left>
This example provides a short description of how to use the ADC peripheral
with sequencer to convert several channels.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="CAN">CAN</p></td>
        <td align=left><p id="CAN_Networking">CAN_Networking</p></td>
        <td align=left>
This example shows how to configure the CAN peripheral to send and receive 
CAN frames in normal mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="COMP">COMP</p></td>
        <td align=left><p id="COMP_AnalogWatchdog">COMP_AnalogWatchdog</p></td>
        <td align=left>
This example shows how to make an analog watchdog using the COMP peripherals in window mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="COMP_Interrupt">COMP_Interrupt</p></td>
        <td align=left>
This example shows how to configure the COMP peripheral to compare the external
voltage applied on a specific pin with the Internal Voltage Reference. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="CRC">CRC</p></td>
        <td align=left><p id="CRC_Bytes_Stream_7bit_CRC">CRC_Bytes_Stream_7bit_CRC</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the 
HAL API. The CRC (Cyclic Redundancy Check) calculation unit computes 7-bit long 
CRC codes derived from buffers of 8-bit data (bytes).
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRC_Data_Reversing_16bit_CRC">CRC_Data_Reversing_16bit_CRC</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the 
HAL API. The CRC (Cyclic Redundancy Check) calculation unit computes a 16-bit long 
CRC code derived from a buffer of 8-bit data (bytes).
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRC_Example">CRC_Example</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the 
HAL API. The CRC (Cyclic Redundancy Check) calculation unit computes the CRC code 
of a given buffer of 32-bit data words, using a fixed generator polynomial (0x4C11DB7).
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRC_UserDefinedPolynomial">CRC_UserDefinedPolynomial</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the 
HAL API. The CRC (Cyclic Redundancy Check) calculation unit computes the 8-bit long 
CRC code of a given buffer of 32-bit data words, based on a user-defined generating polynomial. 
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="CRYP">CRYP</p></td>
        <td align=left><p id="CRYP_AESModes">CRYP_AESModes</p></td>
        <td align=left>
This example provides a short description of how to use the CRYP peripheral to
encrypt and decrypt data using AES in chaining modes (ECB, CBC, CTR).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRYP_AESModes_Suspension">CRYP_AESModes_Suspension</p></td>
        <td align=left>
This example provides a short description of how to use the CRYP AES peripheral to
suspend then resume the AES ECB, CBC and CTR processing of a message in order to
carry out the encryption or decryption of a higher priority message. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRYP_DMA">CRYP_DMA</p></td>
        <td align=left>
This example provides a short description of how to use the CRYP peripheral to 
encrypt and decrypt data using AES 128 Algorithm with ECB chaining mode in DMA mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRYP_GCM_GMAC_CMAC_Modes">CRYP_GCM_GMAC_CMAC_Modes</p></td>
        <td align=left>
This example describes how to encrypt, decrypt data and compute authentication tag 
with GCM, GMAC and CMAC AES algorithms.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRYP_GCM_GMAC_CMAC_Suspension">CRYP_GCM_GMAC_CMAC_Suspension</p></td>
        <td align=left>
This example provides a short description of how to use the CRYP AES peripheral to
suspend then resume the AES GCM, GMAC and CMAC processing of a message in order to
carry out the encryption, decryption or authentication tag computation of a higher 
priority message. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="Cortex">Cortex</p></td>
        <td align=left><p id="CORTEXM_MPU">CORTEXM_MPU</p></td>
        <td align=left>
This example presents the MPU feature. Its purpose is to configure a memory area
as privileged read-only area and attempt to perform read and write operations
in different modes.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORTEXM_ModePrivilege">CORTEXM_ModePrivilege</p></td>
        <td align=left>
This example shows how to modify Thread mode privilege access and stack. Thread 
mode is entered on reset or when returning from an exception.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORTEXM_ProcessStack">CORTEXM_ProcessStack</p></td>
        <td align=left>
This example shows how to modify Thread mode stack. Thread mode is entered on Reset, 
and can be entered as a result of an exception return.  
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CORTEXM_SysTick">CORTEXM_SysTick</p></td>
        <td align=left>
This example shows how to use the default SysTick configuration with a 1 ms timebase 
to toggle LEDs.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="DAC">DAC</p></td>
        <td align=left><p id="DAC_SignalsGeneration">DAC_SignalsGeneration</p></td>
        <td align=left>
This example provides a description of how to use the DAC peripheral to 
generate several signals using DMA controller.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DAC_SimpleConversion">DAC_SimpleConversion</p></td>
        <td align=left>
This example provides a short description of how to use the DAC peripheral to 
do a simple conversion.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="DCMI">DCMI</p></td>
        <td align=left><p id="DCMI_CaptureMode">DCMI_CaptureMode</p></td>
        <td align=left>
This example provides a short description of how to use the DCMI interfaced with a
camera module, continuously capture RGB565 images, crop them from size 320x240 to 240x240
then display the video stream on LCD.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DCMI_Preview">DCMI_Preview</p></td>
        <td align=left>
This example provides a short description of how to use the DCMI interfaced with a
camera module, continuously capture RGB565 images, crop them from size 320x240 to 240x240
then display the video stream on LCD with the possibility to freeze/unfreeze the video stream.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DCMI_SnapshotMode">DCMI_SnapshotMode</p></td>
        <td align=left>
This example provides a short description of how to use the DCMI to interface with
a camera module, capture a single RGB565 image and crop it from size 320x240 to 240x240,
and once full frame camera is captured, display it on a 240x240 LCD in RGB565 format.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="DFSDM">DFSDM</p></td>
        <td align=left><p id="DFSDM_AudioRecord">DFSDM_AudioRecord</p></td>
        <td align=left>
This example shows how to use the DFSDM HAL API to perform stereo audio recording.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DFSDM_Thermometer">DFSDM_Thermometer</p></td>
        <td align=left>
This example shows how to use the DFSDM HAL API to perform temperature measurements.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="DMA">DMA</p></td>
        <td align=left><p id="DMA_FLASHToRAM">DMA_FLASHToRAM</p></td>
        <td align=left>
This example provides a description of how to use a DMA channel to transfer 
a word data buffer from Flash memory to embedded SRAM through 
the HAL API.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="DMA2D">DMA2D</p></td>
        <td align=left><p id="DMA2D_MemToMemWithBlending">DMA2D_MemToMemWithBlending</p></td>
        <td align=left>
  This example provides a description of how to configure DMA2D peripheral in 
  Memory_to_Memory with blending transfer mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_MemToMemWithLCD">DMA2D_MemToMemWithLCD</p></td>
        <td align=left>
  This example provides a description of how to configure DMA2D peripheral in 
  Memory_to_Memory transfer mode and display the result on LCD.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_MemToMemWithPFC">DMA2D_MemToMemWithPFC</p></td>
        <td align=left>
  This example provides a description of how to configure DMA2D peripheral for transfer 
  in Memory_to_Memory with Pixel Format Conversion (PFC) Mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_MemoryToMemory">DMA2D_MemoryToMemory</p></td>
        <td align=left>
This example provides a description of how to configure the DMA2D peripheral in 
Memory_to_Memory transfer mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_RegToMemWithLCD">DMA2D_RegToMemWithLCD</p></td>
        <td align=left>
  This example provides a description of how to configure DMA2D peripheral in 
  Register_to_Memory transfer mode and display the result on LCD.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="DSI">DSI</p></td>
        <td align=left><p id="DSI_CmdMode_SingleBuffer">DSI_CmdMode_SingleBuffer</p></td>
        <td align=left>
This example provides a description of how to use the embedded LCD DSI controller
(using IPs GFXMMU, LTDC and DSI Host) to drive the round LCD mounted on board and
display a 390x390 RGB image on LCD in Command mode using a single buffer for draw.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DSI_ULPM_Data">DSI_ULPM_Data</p></td>
        <td align=left>
This example provides a description of how to use the embedded LCD DSI controller
(using IPs GFXMMU, LTDC and DSI Host) to drive the round LCD mounted on board and
manage entry and exit in DSI ULPM mode on data lane only. In this mode, the DSI PHY
state machine is entering a low power state on data lane and allows to save some power
when the LCD does not need to display. When the display is needed again, the DSI ULPM
on data lane is exited and display should operate as before.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DSI_ULPM_DataClock">DSI_ULPM_DataClock</p></td>
        <td align=left>
This example provides a description of how to use the embedded LCD DSI controller
(using IPs GFXMMU, LTDC and DSI Host) to drive the round LCD mounted on board and
manage entry and exit in DSI ULPM mode on data lane and clock lane. In this mode,
the DSI PHY state machine is entering a low power state on data lane and clock lane.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="FIREWALL">FIREWALL</p></td>
        <td align=left><p id="FIREWALL_VolatileData_Executable">FIREWALL_VolatileData_Executable</p></td>
        <td align=left> 
This example shows how to use the Firewall peripherak to protect a volatile data segment 
and define it as executable.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FIREWALL_VolatileData_Shared">FIREWALL_VolatileData_Shared</p></td>
        <td align=left> 
This example shows how to use the Firewall peripheral to protect a code segment as well 
as volatile and non-volatile data segments.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="FLASH">FLASH</p></td>
        <td align=left><p id="FLASH_DualBoot">FLASH_DualBoot</p></td>
        <td align=left>
This example guides you through the different configuration steps to program the internal 
flash memory bank 1 and bank 2 and to swap between both of them by mean of the FLASH HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FLASH_EraseProgram">FLASH_EraseProgram</p></td>
        <td align=left>
This example describes how to configure and use the FLASH HAL API to erase and program
the internal Flash memory.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FLASH_FastProgram">FLASH_FastProgram</p></td>
        <td align=left>
This example describes how to configure and use the FLASH HAL API to erase and fast 
program the internal Flash memory.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FLASH_WriteProtection">FLASH_WriteProtection</p></td>
        <td align=left>
This example describes how to configure and use the FLASH HAL API to enable and 
disable the write protection of the internal Flash memory.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="FMC">FMC</p></td>
        <td align=left><p id="FMC_NOR">FMC_NOR</p></td>
        <td align=left>
This example describes how to configure the FMC controller to access the NOR memory.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FMC_SRAM">FMC_SRAM</p></td>
        <td align=left>
This example describes how to configure the FMC controller to access the SRAM 
memory.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="GPIO">GPIO</p></td>
        <td align=left><p id="GPIO_EXTI">GPIO_EXTI</p></td>
        <td align=left>
This example shows how to configure external interrupt lines to wake up from low power mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="GPIO_IOToggle">GPIO_IOToggle</p></td>
        <td align=left>
This example describes how to configure and use GPIOs through the HAL API. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="HAL">HAL</p></td>
        <td align=left><p id="HAL_RegisterCallbacks_TIM">HAL_RegisterCallbacks_TIM</p></td>
        <td align=left>
Register a callback function called every second based on TIM peripheral
configuration to generate a timebase of one second with the corresponding
interrupt request.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=red>New</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HAL_TimeBase_TIM">HAL_TimeBase_TIM</p></td>
        <td align=left>
This example describes how to customize the HAL time base using a general 
purpose timer instead of Systick as main source of time base.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=9><p id="HASH">HASH</p></td>
        <td align=left><p id="HASH_HMAC_SHA1MD5">HASH_HMAC_SHA1MD5</p></td>
        <td align=left>
This example provides a short description of how to use the HASH peripheral to 
hash data using HMAC SHA-1 and HMAC MD5 algorithms.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_HMAC_SHA224SHA1_DMA_Suspension">HASH_HMAC_SHA224SHA1_DMA_Suspension</p></td>
        <td align=left>
This example describes how to suspend the HMAC digest computation when data are fed 
to the HASH IP by DMA.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_HMAC_SHA224SHA256_MultiBuffer_DMA">HASH_HMAC_SHA224SHA256_MultiBuffer_DMA</p></td>
        <td align=left>
This example describes how to handle text messages larger than the maximum DMA 
transfer length. In this case, the input data have to be split into several buffers 
with sizes within the DMA limit, and the buffers must be consecutively fed to the 
HASH peripheral.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_HMAC_SHA256MD5_IT_Suspension">HASH_HMAC_SHA256MD5_IT_Suspension</p></td>
        <td align=left>
This example describes how to suspend the HMAC digest computation when data are fed 
in Interrupt mode.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_SHA1MD5">HASH_SHA1MD5</p></td>
        <td align=left>
This example provides a short description of how to use the HASH peripheral to 
hash data using SHA-1 and MD5 algorithms.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_SHA1MD5_DMA">HASH_SHA1MD5_DMA</p></td>
        <td align=left>
This example provides a short description of how to use the HASH peripheral to 
hash data using SHA-1 and MD5 algorithms when data are fed to the HASH IP by DMA.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_SHA1SHA224_IT_Suspension">HASH_SHA1SHA224_IT_Suspension</p></td>
        <td align=left>
This example describes how to suspend the HASH peripheral when data are fed 
in Interrupt mode.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_SHA224SHA256_DMA">HASH_SHA224SHA256_DMA</p></td>
        <td align=left>
This example provides a short description of how to use the HASH peripheral to 
hash data using SHA224 and SHA256 algorithms.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HASH_SHA256MD5_DMA_Suspension">HASH_SHA256MD5_DMA_Suspension</p></td>
        <td align=left>
This example describes how to suspend the HASH peripheral when data are fed 
to the HASH IP by DMA.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=10><p id="I2C">I2C</p></td>
        <td align=left><p id="I2C_EEPROM">I2C_EEPROM</p></td>
        <td align=left>
This example describes how to ensure I2C data buffer transmission/reception 
with DMA. Data are exchanged with an I2C EEPROM memory.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_IOExpander">I2C_IOExpander</p></td>
        <td align=left>
This example describes how to perform I2C data communication with the I/O expander 
device mounted on the evaluation board.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_AdvComIT">I2C_TwoBoards_AdvComIT</p></td>
        <td align=left>
This example describes how to perform I2C data buffer transmission/reception 
between two boards, using an interrupt.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_ComDMA">I2C_TwoBoards_ComDMA</p></td>
        <td align=left>
This example describes how to perform I2C data buffer transmission/reception 
between two boards, via DMA.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_ComIT">I2C_TwoBoards_ComIT</p></td>
        <td align=left>
This example describes how to perform I2C data buffer transmission/reception between 
two boards using an interrupt.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_ComPolling">I2C_TwoBoards_ComPolling</p></td>
        <td align=left>
This example describes how to perform I2C data buffer transmission/reception between 
two boards in Polling mode.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_RestartAdvComIT">I2C_TwoBoards_RestartAdvComIT</p></td>
        <td align=left>
This example describes how to perform a multiple I2C data buffer transmission/reception
between two boards in Interrupt mode and with advanced restart condition.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_RestartComIT">I2C_TwoBoards_RestartComIT</p></td>
        <td align=left>
This example describes how to perform a single I2C data buffer transmission/reception
between two boards in Interrupt mode and with a restart condition.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_WakeUpFromStop">I2C_WakeUpFromStop</p></td>
        <td align=left>
This example describes how to perform I2C data buffer transmission/reception between 
two boards using an interrupt when the device is in Stop mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_WakeUpFromStop2">I2C_WakeUpFromStop2</p></td>
        <td align=left>
This example describes how to perform I2C data buffer transmission/reception between 
two boards using an interrupt when the device is in Stop 2 mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="IWDG">IWDG</p></td>
        <td align=left><p id="IWDG_Reset">IWDG_Reset</p></td>
        <td align=left>
This example describes how to ensure IWDG reload counter and simulate a software
fault that generates an MCU IWDG reset when a programmed time period has elapsed.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="IWDG_WindowMode">IWDG_WindowMode</p></td>
        <td align=left>
This example describes how to periodically update the IWDG reload counter and
simulate a software fault that generates an MCU IWDG reset when a programmed
time period has elapsed.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="LCD">LCD</p></td>
        <td align=left><p id="LCD_Blink_Frequency">LCD_Blink_Frequency</p></td>
        <td align=left>
This example describes how to use the embedded LCD glass controller and how to configure the 
LCD blink mode and blinking frequency.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LCD_SegmentsDrive">LCD_SegmentsDrive</p></td>
        <td align=left>
This example describes how to use the embedded LCD controller to drive the Pacific Display LCD glass 
mounted on the board.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="LPTIM">LPTIM</p></td>
        <td align=left><p id="LPTIM_PWMExternalClock">LPTIM_PWMExternalClock</p></td>
        <td align=left>
This example describes how to configure and use LPTIM to generate a PWM at the
lowest power consumption, using an external counter clock, through the HAL LPTIM API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LPTIM_PWM_LSE">LPTIM_PWM_LSE</p></td>
        <td align=left>
This example describes how to configure and use LPTIM to generate a PWM in low power mode
using the LSE as a counter clock, through the HAL LPTIM API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LPTIM_PulseCounter">LPTIM_PulseCounter</p></td>
        <td align=left>
This example describes how to configure and use LPTIM to count pulses through
the LPTIM HAL API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LPTIM_Timeout">LPTIM_Timeout</p></td>
        <td align=left>
This example describes how to implement a low power timeout to wake-up the 
system using the LPTIMER, through the HAL LPTIM API. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="LPUART">LPUART</p></td>
        <td align=left><p id="LPUART_TwoBoards_ComIT">LPUART_TwoBoards_ComIT</p></td>
        <td align=left>
This example describes a LPUART transmission (transmit/receive) in interrupt mode
between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LPUART_WakeUpFromStop">LPUART_WakeUpFromStop</p></td>
        <td align=left>
This example shows how to configure a LPUART to wake up the MCU from STOP mode
when a given stimulus is received.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="LTDC">LTDC</p></td>
        <td align=left><p id="LTDC_ColorKeying">LTDC_ColorKeying</p></td>
        <td align=left>
  This example describe how to enable and use the LTDC color keying functionality.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LTDC_Display_1Layer">LTDC_Display_1Layer</p></td>
        <td align=left>
  This example provides a description of how to configure LTDC peripheral to 
  display an RGB image of size 480x272 and format RGB565 (16 bits/pixel) on LCD using only one layer.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LTDC_Display_2Layers">LTDC_Display_2Layers</p></td>
        <td align=left>
  This example describes how to configure the LTDC peripheral to display two Layers  
  at the same time.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="OPAMP">OPAMP</p></td>
        <td align=left><p id="OPAMP_PGA">OPAMP_PGA</p></td>
        <td align=left>
This example shows how to use the built-in PGA mode (OPAMP programmable gain).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OPAMP_STANDALONE">OPAMP_STANDALONE</p></td>
        <td align=left>
This example shows how to configure OPAMP peripheral in standalone mode. The gain 
in this mode can be set externally (external gain setting mode). 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=9><p id="OSPI">OSPI</p></td>
        <td align=left><p id="OSPI_NOR_ExecuteInPlace">OSPI_NOR_ExecuteInPlace</p></td>
        <td align=left>
This example describes how to execute a part of the code from the OSPI  NOR memory. To do this, 
a section is created where the function is stored.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_NOR_ExecuteInPlace_DTR">OSPI_NOR_ExecuteInPlace_DTR</p></td>
        <td align=left>
This example describes how to execute a part of the code from the OSPI  NOR memory. To do this, 
a section is created where the function is stored.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_NOR_MemoryMapped">OSPI_NOR_MemoryMapped</p></td>
        <td align=left>
This example describes how to erase part of the OSPI NOR memory, write data in memory-mapped mode and 
access to OSPI NOR memory in memory-mapped mode to check the data in a forever loop.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_NOR_MemoryMapped_DTR">OSPI_NOR_MemoryMapped_DTR</p></td>
        <td align=left>
This example describes how to erase part of the OSPI NOR memory, write data in memory-mapped mode and 
access to OSPI NOR memory in memory-mapped mode to check the data in a forever loop. The memory is 
configured in octal DTR mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_NOR_ReadWrite_DMA">OSPI_NOR_ReadWrite_DMA</p></td>
        <td align=left>
This example describes how to erase part of the OSPI NOR memory, write data in DMA mode, read data in DMA mode 
and compare the result in a forever loop.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_NOR_ReadWrite_DMA_DTR">OSPI_NOR_ReadWrite_DMA_DTR</p></td>
        <td align=left>
This example describes how to erase part of the OSPI NOR memory, write data in DMA mode, read data in DMA mode 
and compare the result in a forever loop. The memory is configured in octal DTR mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_RAM_ExecuteInPlace">OSPI_RAM_ExecuteInPlace</p></td>
        <td align=left>
This example describes how to execute a part of the code from the OSPI HyperRAM memory. To do this, 
a section is created where the function is stored.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_RAM_MemoryMapped">OSPI_RAM_MemoryMapped</p></td>
        <td align=left>
This example describes how to write and read data in memory-mapped mode in the OSPI 
HyperRAM memory and compare the result in a forever loop.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OSPI_RAM_ReadWrite_DMA">OSPI_RAM_ReadWrite_DMA</p></td>
        <td align=left>
This example describes how to write data in DMA mode in the OSPI HyperRAM memory, read data in DMA mode 
and compare the result in a forever loop.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=15><p id="PWR">PWR</p></td>
        <td align=left><p id="PWR_LPRUN">PWR_LPRUN</p></td>
        <td align=left> 
This example shows how to enter and exit the Low-power Run mode.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_LPRUN_SRAM1">PWR_LPRUN_SRAM1</p></td>
        <td align=left> 
This example shows how to enter and exit the Low Power Run mode.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_LPSLEEP">PWR_LPSLEEP</p></td>
        <td align=left>
This example shows how to enter Low-power sleep mode and wake up from this mode using 
an interrupt.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_ModesSelection">PWR_ModesSelection</p></td>
        <td align=left> 
This example shows how to enter the power mode selected by the user application from an 
Hyperterminal console on a remote Host computer. The objective is to provide a mean to 
measure the power consumption using an amperemeter on IDD connector. 
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_RUN_SMPS">PWR_RUN_SMPS</p></td>
        <td align=left> 
This example shows how to use SMPS in Run mode and access the power consumption
gain obtained when the SMPS feature is used.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_SHUTDOWN">PWR_SHUTDOWN</p></td>
        <td align=left> 
This example shows how to enter Shutdown mode and wake up from this mode using 
an external reset or the WKUP pin.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_SLEEP">PWR_SLEEP</p></td>
        <td align=left>
This example shows how to enter Sleep mode and wake up from this mode by using 
an interrupt.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STANDBY">PWR_STANDBY</p></td>
        <td align=left> 
This example shows how to enter Standby mode and wake up from this mode using 
an external reset or the WKUP pin.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STANDBY_RTC">PWR_STANDBY_RTC</p></td>
        <td align=left>
This example shows how to enter Standby mode and wake up from this mode using 
an external reset or the RTC Wakeup timer

In the associated software, the system clock is set to 120 MHz and the SysTick is 
programmed to generate an interrupt each 1 ms.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STANDBY_SMPS">PWR_STANDBY_SMPS</p></td>
        <td align=left> 
This example shows how to enter SMPS Standby mode and wake up from this mode using 
an interrupt.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP0_SMPS">PWR_STOP0_SMPS</p></td>
        <td align=left> 
This example shows how to enter SMPS Stop 0 mode and wake up from this mode using 
an interrupt.
</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP1">PWR_STOP1</p></td>
        <td align=left> 
This example shows how to enter Stop 1 mode and wake up from this mode using 
an interrupt.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP1_RTC">PWR_STOP1_RTC</p></td>
        <td align=left>
This example shows how to enter Stop 1 mode and wake up from this mode using 
an interrupt from RTC Wake-up Timer. 
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP2">PWR_STOP2</p></td>
        <td align=left> 
This example shows how to enter Stop 2 mode and wake up from this mode using an 
external reset or a wakeup interrupt

In the associated software, the system clock is set to 120 MHz, an EXTI line
is connected to the user button thru PC.13 and configured to generate an 
interrupt on falling edge upon key press.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP2_RTC">PWR_STOP2_RTC</p></td>
        <td align=left>
This example shows how to enter Stop 2 mode and wake up from this mode using an 
external reset or the RTC Wakeup timer.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="QSPI">QSPI</p></td>
        <td align=left><p id="QSPI_ExecuteInPlace">QSPI_ExecuteInPlace</p></td>
        <td align=left>
This example describes how to execute a part of the code from the QuadSPI Flash memory. To do this, 
a section is created where the function is stored.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="QSPI_MemoryMapped">QSPI_MemoryMapped</p></td>
        <td align=left>
This example describes how to erase part of the QuadSPI Flash memory, write data in DMA mode and 
access to QuadSPI Flash memory in memory-mapped mode to check the data in a forever loop.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="QSPI_PreInitConfig">QSPI_PreInitConfig</p></td>
        <td align=left>
This example describes how to execute a part of the code from the QuadSPI Flash memory configured in 
memory-mapped mode before the call to main() function so that QuadSPI Flash memory is available after the reset.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="QSPI_ReadWrite_DMA">QSPI_ReadWrite_DMA</p></td>
        <td align=left>
This example describes how to erase part of the QuadSPI Flash memory, write data in DMA mode, read data in DMA mode 
and compare the result in a forever loop.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="QSPI_ReadWrite_IT">QSPI_ReadWrite_IT</p></td>
        <td align=left>
This example describes how to erase part of the QuadSPI Flash memory, write data in Interrupt mode, read data 
in Interrupt mode and compare the result in a forever loop.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="RCC">RCC</p></td>
        <td align=left><p id="RCC_CRS_Synchronization_IT">RCC_CRS_Synchronization_IT</p></td>
        <td align=left>
This example describes how to use the RCC HAL API to configure the clock recovery service (CRS)
in Interrupt mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_CRS_Synchronization_Polling">RCC_CRS_Synchronization_Polling</p></td>
        <td align=left>
This example describes how to use the RCC HAL API to configure the clock recovery service (CRS)
in Polling mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_ClockConfig">RCC_ClockConfig</p></td>
        <td align=left>
This example describes how to use the RCC HAL API to configure the system clock (SYSCLK) 
and modify the clock settings in Run mode.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="RNG">RNG</p></td>
        <td align=left><p id="RNG_MultiRNG">RNG_MultiRNG</p></td>
        <td align=left>
This example guides you through the HAL API different configuration steps 
to ensure 32-bit long random numbers generation by RNG peripheral.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RNG_MultiRNG_IT">RNG_MultiRNG_IT</p></td>
        <td align=left>
This example guides you through the HAL API different configuration steps 
to ensure 32-bit long random numbers generation by RNG peripheral interruptions.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=7><p id="RTC">RTC</p></td>
        <td align=left><p id="RTC_Alarm">RTC_Alarm</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the RTC 
HAL API to configure and generate an RTC alarm.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Calendar">RTC_Calendar</p></td>
        <td align=left>
This example guides you through the different configuration steps by mean of HAL API
to ensure Calendar configuration using the RTC peripheral.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_InternalTimeStamp">RTC_InternalTimeStamp</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the RTC 
HAL API to demonstrate the internal timestamp feature.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_LSI">RTC_LSI</p></td>
        <td align=left>
This example demonstrates and explains how to use the LSI clock source auto
calibration to get a precise RTC clock. 
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_LowPower_STANDBY">RTC_LowPower_STANDBY</p></td>
        <td align=left> 
This example shows how to enter Standby mode and wake up from this mode using the
RTC alarm event.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Tamper">RTC_Tamper</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the RTC
HAL API to write/read data to/from RTC Backup registers. It also demonstrates the tamper
detection feature.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_TimeStamp">RTC_TimeStamp</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the RTC 
HAL API to demonstrate the timestamp feature.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="SAI">SAI</p></td>
        <td align=left><p id="SAI_AudioPlay">SAI_AudioPlay</p></td>
        <td align=left>
This example shows how to use the SAI HAL API to play an audio file using the DMA 
circular mode and how to handle the buffer update.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="SMARTCARD">SMARTCARD</p></td>
        <td align=left><p id="SMARTCARD_T0">SMARTCARD_T0</p></td>
        <td align=left>
This example describes a firmware smartcard Interface based on USART. The main purpose
of this firmware example is to provide resources that ease the development of applications
using USART in smartcard mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="SPI">SPI</p></td>
        <td align=left><p id="SPI_FullDuplex_ComDMA">SPI_FullDuplex_ComDMA</p></td>
        <td align=left>
This example shows how to perform SPI data buffer transmission/reception between 
two boards via DMA.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComIT">SPI_FullDuplex_ComIT</p></td>
        <td align=left>
This example shows how to ensure SPI data buffer transmission/reception between 
two boards by using an interrupt.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_FullDuplex_ComPolling">SPI_FullDuplex_ComPolling</p></td>
        <td align=left>
This example shows how to ensure SPI data buffer transmission/reception in Polling 
mode between two boards.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_HalfDuplex_ComPolling">SPI_HalfDuplex_ComPolling</p></td>
        <td align=left>
This example shows how to ensure SPI data buffer half-duplex transmission/reception 
in Polling mode between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="SWPMI">SWPMI</p></td>
        <td align=left><p id="SWPMI_Session">SWPMI_Session</p></td>
        <td align=left>
This example shows how to use the SWPMI interface and open a communication session with 
a SWP compliant card in no software buffer mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=11><p id="TIM">TIM</p></td>
        <td align=left><p id="TIM_DMA">TIM_DMA</p></td>
        <td align=left>
This example provides a description of how to use DMA with TIMER Update request
to transfer Data from memory to TIMER Capture Compare Register 3 (TIMx_CCR3).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_DMABurst">TIM_DMABurst</p></td>
        <td align=left>
This example shows how to update the TIMER channel1 period and the duty cycle 
using the TIMER DMA burst feature.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_ExtTriggerSynchro">TIM_ExtTriggerSynchro</p></td>
        <td align=left>
 This example shows how to synchronize TIM peripherals in cascade mode with an
  external trigger.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_InputCapture">TIM_InputCapture</p></td>
        <td align=left>
  This example shows how to use the TIM peripheral to measure the frequency of
  an external signal.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OCActive">TIM_OCActive</p></td>
        <td align=left>
  This example shows how to configure the TIM peripheral in Output Compare Active 
  mode (when the counter matches the capture/compare register, the concerned output
  pin is set to its active state).
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OCInactive">TIM_OCInactive</p></td>
        <td align=left>
  This example shows how to configure the TIM peripheral in Output Compare Inactive 
  mode with the corresponding Interrupt requests for each channel.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OCToggle">TIM_OCToggle</p></td>
        <td align=left>
  This example shows how to configure the TIM peripheral to generate four different 
  signals with four different frequencies.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OnePulse">TIM_OnePulse</p></td>
        <td align=left>
This example shows how to use the TIM peripheral to generate a single pulse when
a rising edge of an external signal is received on the timer Input pin.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_PWMInput">TIM_PWMInput</p></td>
        <td align=left>
This example shows how to use the TIM peripheral to measure the frequency and 
duty cycle of an external signal.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_PWMOutput">TIM_PWMOutput</p></td>
        <td align=left>
This example shows how to configure the TIM peripheral in PWM (Pulse Width Modulation) 
mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_TimeBase">TIM_TimeBase</p></td>
        <td align=left>
This example shows how to configure the TIM peripheral to generate a time base of 
one second with the corresponding Interrupt request.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="TSC">TSC</p></td>
        <td align=left><p id="TSC_BasicAcquisition_Interrupt">TSC_BasicAcquisition_Interrupt</p></td>
        <td align=left>
This example describes how to use the HAL TSC to perform continuous acquisitions
of one channel in interrupt mode.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=8><p id="UART">UART</p></td>
        <td align=left><p id="LPUART_WakeUpFromStop">LPUART_WakeUpFromStop</p></td>
        <td align=left>
This example shows how to configure a LPUART to wake up the MCU from STOP mode
when a given stimulus is received.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_HyperTerminal_DMA">UART_HyperTerminal_DMA</p></td>
        <td align=left>
This example describes an UART transmission (transmit/receive) in DMA mode
between a board and an HyperTerminal PC application.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_LowPower_HyperTerminal_DMA">UART_LowPower_HyperTerminal_DMA</p></td>
        <td align=left>
This example describes an low power UART transmission (transmit/receive) in DMA mode
between a board and an Hyperterminal PC application.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_Printf">UART_Printf</p></td>
        <td align=left>
This example shows how to re-route the C library printf function to the UART.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_TwoBoards_ComDMA">UART_TwoBoards_ComDMA</p></td>
        <td align=left>
This example describes an UART transmission (transmit/receive) in DMA mode
between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_TwoBoards_ComIT">UART_TwoBoards_ComIT</p></td>
        <td align=left>
This example describes an UART transmission (transmit/receive) in interrupt mode
between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_TwoBoards_ComPolling">UART_TwoBoards_ComPolling</p></td>
        <td align=left>
This example describes an UART transmission (transmit/receive) in polling mode
between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_WakeUpFromStop">UART_WakeUpFromStop</p></td>
        <td align=left>
This example shows how to configure an UART to wake up the MCU from Stop 1 mode
when a given stimulus is received.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="WWDG">WWDG</p></td>
        <td align=left><p id="WWDG_Example">WWDG_Example</p></td>
        <td align=left>
This example guides you through the different configuration steps by means of the 
HAL API to perform periodic WWDG counter update and simulate a software fault that 
generates an MCU WWDG reset when a predefined time period has elapsed.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of examples: 570</b></td>
        <td>3</td>
        <td>50</td>
        <td>87</td>
        <td>62</td>
        <td>82</td>
        <td>17</td>
        <td>1</td>
        <td>97</td>
        <td>3</td>
        <td>70</td>
        <td>54</td>
        <td>3</td>
        <td>3</td>
        <td>16</td>
        <td>22</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=96><p id="Examples_LL">Examples_LL</p></td>
        <td align=left rowspan=13><p id="ADC">ADC</p></td>
        <td align=left><p id="ADC_AnalogWatchdog">ADC_AnalogWatchdog</p></td>
        <td align=left>
This example describes how to use a ADC peripheral with ADC analog watchdog
to monitor a channel and detect when the corresponding conversion data is
out of window thresholds. This example is based on the STM32L4xx ADC 
LL API. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_ContinuousConversion_TriggerSW">ADC_ContinuousConversion_TriggerSW</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to perform continuous ADC conversions 
of a channel, from a software start. This example is based on the STM32L4xx ADC 
LL API. The peripheral initialization is done using LL unitary service functions 
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_ContinuousConversion_TriggerSW_Init">ADC_ContinuousConversion_TriggerSW_Init</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to perform continuous ADC conversions 
of a channel, from a software start. This example is based on the STM32L4xx ADC 
LL API. The peripheral initialization is done using LL initialization function to 
demonstrate LL init usage. 
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_ContinuousConversion_TriggerSW_LowPower">ADC_ContinuousConversion_TriggerSW_LowPower</p></td>
        <td align=left>
This example describes how to use a ADC peripheral with ADC low-power features. This 
example is based on the STM32L4xx ADC LL API. The peripheral initialization is done 
using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_GroupsRegularInjected">ADC_GroupsRegularInjected</p></td>
        <td align=left>
This example describes how to use a ADC peripheral with both ADC groups
(ADC group regular and ADC group injected) in their intended use case. This 
example is based on the the STM32L4xx ADC LL API. The peripheral initialization is done
using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_MultiChannelSingleConversion">ADC_MultiChannelSingleConversion</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to convert several channels, 
ADC conversions are performed successively in a scan sequence. This example is based 
on the STM32L4xx ADC LL API. The peripheral initialization done using 
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_MultimodeDualInterleaved">ADC_MultimodeDualInterleaved</p></td>
        <td align=left>
This example describes how to use several ADC peripherals in multimode,
mode interleaved. This example is based on the STM32L4xx ADC LL
API. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_Oversampling">ADC_Oversampling</p></td>
        <td align=left>
This example describes how to use a ADC peripheral with ADC oversampling. This example 
is based on the STM32L4xx ADC LL API. The peripheral initialization done using LL
unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW">ADC_SingleConversion_TriggerSW</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to perform a single ADC conversion
of a channel, at each software start. This example uses the polling programming model 
(for interrupt or DMA programming models, refer to other examples). This example is based 
on the STM32L4xx ADC LL API. The peripheral initialization is done using LL unitary 
service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_DMA">ADC_SingleConversion_TriggerSW_DMA</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to perform a single ADC conversion
of a channel, at each software start. This example uses the DMA programming model 
(for polling or interrupt programming models, refer to other examples). This example is based 
on the STM32L4xx ADC LL API. The peripheral initialization is done using LL unitary 
service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_IT">ADC_SingleConversion_TriggerSW_IT</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to perform a single ADC conversion
of a channel, at each software start. This example uses the interrupt programming model 
(for polling or DMA programming models, refer to other examples). This example is based 
on the STM32L4xx ADC LL API. The peripheral initialization is done using LL unitary 
service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_SingleConversion_TriggerTimer_DMA">ADC_SingleConversion_TriggerTimer_DMA</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to perform a single ADC conversion
of a channel at each trigger event from timer. Converted data are indefinitely transferred 
by DMA into a table (circular mode). This example is based on the STM32L4xx ADC LL 
API. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="ADC_TemperatureSensor">ADC_TemperatureSensor</p></td>
        <td align=left>
This example describes how to use a ADC peripheral to perform a single ADC conversion
of the internal temperature sensor and calculate the temperature in Celsius degrees. This 
example uses the polling programming model (for interrupt or DMA programming models, refer
to other examples). This example is based on the STM32L4xx ADC LL API. The peripheral 
initialization is done using LL unitary service functions for optimization 
purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="COMP">COMP</p></td>
        <td align=left><p id="COMP_CompareGpioVsVrefInt_IT">COMP_CompareGpioVsVrefInt_IT</p></td>
        <td align=left>
This example describes how to use a comparator peripheral to compare a voltage
level applied on a GPIO pin with the internal voltage reference (VREFINT), in interrupt
mode. This example is based on the STM32L4xx COMP LL API. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="COMP_CompareGpioVsVrefInt_IT_Init">COMP_CompareGpioVsVrefInt_IT_Init</p></td>
        <td align=left>
This example describes how to use a comparator peripheral to compare a voltage
level applied on a GPIO pin with the internal voltage reference (VREFINT), in interrupt
mode. This example is based on the STM32L4xx COMP LL API. The peripheral initialization
is done using LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="COMP_CompareGpioVsVrefInt_OutputGpio">COMP_CompareGpioVsVrefInt_OutputGpio</p></td>
        <td align=left>
This example describes how to use a comparator peripheral to compare a voltage
level applied on a GPIO pin with the internal voltage reference (VREFINT). The 
comparator output is connected to a GPIO. This example is based on the STM32L4xx COMP LL
API. The peripheral initialization is done using LL unitary service functions for
optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="COMP_CompareGpioVsVrefInt_Window_IT">COMP_CompareGpioVsVrefInt_Window_IT</p></td>
        <td align=left>
This example describes how to use a pair of comparator peripherals to compare a
voltage level applied on a GPIO pin with two thresholds: the internal voltage
reference (VREFINT) and a fraction of the internal voltage reference (VREFINT/2),
in interrupt mode. This example is based on the STM32L4xx COMP LL API. The 
peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="CORTEX">CORTEX</p></td>
        <td align=left><p id="CORTEX_MPU">CORTEX_MPU</p></td>
        <td align=left>
This example presents the MPU feature. Its purpose is to configure a memory area
as privileged read-only area and attempt to perform read and write operations
in different modes.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="CRC">CRC</p></td>
        <td align=left><p id="CRC_CalculateAndCheck">CRC_CalculateAndCheck</p></td>
        <td align=left>
This example shows how to configure CRC calculation unit to get a CRC code of a given data buffer,
based on a fixed generator polynomial (default value 0x4C11DB7). The peripheral initialization is done 
using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRC_UserDefinedPolynomial">CRC_UserDefinedPolynomial</p></td>
        <td align=left>
This example shows how to configure and use CRC calculation unit to get a 8-bit long CRC of a given data buffer,
based on a user-defined generating polynomial. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="CRS">CRS</p></td>
        <td align=left><p id="CRS_Synchronization_IT">CRS_Synchronization_IT</p></td>
        <td align=left>
This example describes how to configure Clock Recovery Service in Interrupt mode through 
the STM32L4xx CRS LL API. The peripheral initialization is done using 
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="CRS_Synchronization_Polling">CRS_Synchronization_Polling</p></td>
        <td align=left>
This example describes how to configure Clock Recovery Service in polling mode through 
the STM32L4xx CRS LL API. The peripheral initialization is done using 
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="DAC">DAC</p></td>
        <td align=left><p id="DAC_GenerateConstantSignal_TriggerSW">DAC_GenerateConstantSignal_TriggerSW</p></td>
        <td align=left>
This example describes how to use the DAC peripheral to generate a constant voltage
signal. This example is based on the STM32L4xx DAC LL API. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DAC_GenerateConstantSignal_TriggerSW_LP">DAC_GenerateConstantSignal_TriggerSW_LP</p></td>
        <td align=left>
This example describes how to use the DAC peripheral to generate a constant voltage signal
with DAC low-power feature sample-and-hold. To be effective, a capacitor must be connected
to the DAC channel output and the sample-and-hold timings must be tuned depending on the
capacitor value. This example is based on the STM32L4xx DAC LL API. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DAC_GenerateWaveform_TriggerHW">DAC_GenerateWaveform_TriggerHW</p></td>
        <td align=left>
This example describes how to use the DAC peripheral to generate a waveform voltage
from digital data stream transfered by DMA. This example is based on the STM32L4xx
DAC LL API. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DAC_GenerateWaveform_TriggerHW_Init">DAC_GenerateWaveform_TriggerHW_Init</p></td>
        <td align=left>
This example describes how to use the DAC peripheral to generate a waveform voltage
from digital data stream transfered by DMA. This example is based on the STM32L4xx
DAC LL API. The peripheral initialization is done using LL initialization function
to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="DMA">DMA</p></td>
        <td align=left><p id="DMA_CopyFromFlashToMemory">DMA_CopyFromFlashToMemory</p></td>
        <td align=left>
This example describes how to use a DMA channel to transfer a word data buffer
from Flash memory to embedded SRAM. The peripheral initialization is done using
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA_CopyFromFlashToMemory_Init">DMA_CopyFromFlashToMemory_Init</p></td>
        <td align=left>
This example describes how to use a DMA channel to transfer a word data buffer
from Flash memory to embedded SRAM. The peripheral initialization is done using
LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="DMA2D">DMA2D</p></td>
        <td align=left><p id="DMA2D_MemoryToMemory">DMA2D_MemoryToMemory</p></td>
        <td align=left>
This example describes how to configure the DMA2D peripheral in Memory-to-Memory transfer
mode. The example is based on the STM32L4xx DMA2D LL API. The peripheral initialization is done 
using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="EXTI">EXTI</p></td>
        <td align=left><p id="EXTI_ToggleLedOnIT">EXTI_ToggleLedOnIT</p></td>
        <td align=left>
This example describes how to configure the EXTI and use
GPIOs to toggle the user LEDs available on the board when
a user button is pressed. It is based on the STM32L4xx LL
API. The peripheral initialization is done using LL unitary services
functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="EXTI_ToggleLedOnIT_Init">EXTI_ToggleLedOnIT_Init</p></td>
        <td align=left>
This example describes how to configure the EXTI and use
GPIOs to toggle the user LEDs available on the board when
a user button is pressed. This example is based on the
STM32L4xx LL API. The peripheral initialization is done using LL
initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="GPIO">GPIO</p></td>
        <td align=left><p id="GPIO_InfiniteLedToggling">GPIO_InfiniteLedToggling</p></td>
        <td align=left>
This example describes how to configure and use GPIOs to toggle every 250 ms
the user LEDs available on the board. This example is based on the STM32L4xx
LL API. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="GPIO_InfiniteLedToggling_Init">GPIO_InfiniteLedToggling_Init</p></td>
        <td align=left>
This example describes how to configure and use GPIOs to toggle every 250 ms
the user LEDs available on the board. This example is based on the STM32L4xx
LL API. The peripheral initialization is done using LL initialization function to
demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=9><p id="I2C">I2C</p></td>
        <td align=left><p id="I2C_OneBoard_AdvCommunication_DMAAndIT">I2C_OneBoard_AdvCommunication_DMAAndIT</p></td>
        <td align=left>
This example describes how to exchange data between an I2C Master device in DMA mode and
an I2C Slave device in Interrupt mode. The peripheral initialization is done using LL unitary
services functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_OneBoard_Communication_DMAAndIT">I2C_OneBoard_Communication_DMAAndIT</p></td>
        <td align=left>
This example describes how to transmit data bytes from an I2C Master device using DMA mode
to an I2C Slave device using Interrupt mode. The peripheral initialization is done using
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_OneBoard_Communication_IT">I2C_OneBoard_Communication_IT</p></td>
        <td align=left>
This example describes how to receive one data byte from an I2C Slave device to an 
I2C Master device. Both devices operate in Interrupt mode. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_OneBoard_Communication_IT_Init">I2C_OneBoard_Communication_IT_Init</p></td>
        <td align=left>
This example describes how to receive one data byte from an I2C Slave device to an
I2C Master device. Both devices operate in Interrupt mode. The peripheral initialization
is done using LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_OneBoard_Communication_PollingAndIT">I2C_OneBoard_Communication_PollingAndIT</p></td>
        <td align=left>
This example describes how to transmit data bytes from an I2C Master device using Polling mode
to an I2C Slave device using Interrupt mode. The peripheral initialization is done using
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_MasterRx_SlaveTx_IT">I2C_TwoBoards_MasterRx_SlaveTx_IT</p></td>
        <td align=left>  
This example describes how to receive one data byte from an I2C Slave device to an
I2C Master device. Both devices operate in Interrupt mode. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_MasterTx_SlaveRx">I2C_TwoBoards_MasterTx_SlaveRx</p></td>
        <td align=left>
This example describes how to transmit data bytes from an I2C Master device using Polling mode
to an I2C Slave device using Interrupt mode. The peripheral initialization is done using
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_MasterTx_SlaveRx_DMA">I2C_TwoBoards_MasterTx_SlaveRx_DMA</p></td>
        <td align=left>  
This example describes how to transmit data bytes from an I2C Master device using DMA mode
to an I2C Slave device using DMA mode. The peripheral initialization is done using LL
unitary services functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="I2C_TwoBoards_WakeUpFromStop2_IT">I2C_TwoBoards_WakeUpFromStop2_IT</p></td>
        <td align=left>  
This example describes how to receive data byte from an I2C Slave device in Stop2 mode
using Interrupt mode to an I2C Master device Interrupt mode. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="IWDG">IWDG</p></td>
        <td align=left><p id="IWDG_RefreshUntilUserEvent">IWDG_RefreshUntilUserEvent</p></td>
        <td align=left>
This example describes how to configure the IWDG to ensure period counter update and
generate an MCU IWDG reset when a user button is pressed. The peripheral initialization is 
done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="LPTIM">LPTIM</p></td>
        <td align=left><p id="LPTIM_PulseCounter">LPTIM_PulseCounter</p></td>
        <td align=left>
This example describes how to use the LPTIM in counter mode to generate a PWM
output signal and update PWM duty cycle. This example is based on the STM32L4xx
LPTIM LL API. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LPTIM_PulseCounter_Init">LPTIM_PulseCounter_Init</p></td>
        <td align=left>
This example describes how to use the LPTIM in counter mode to generate a PWM
output signal and update PWM duty cycle. This example is based on the STM32L4xx
LPTIM LL API. The peripheral initialization is done using LL initialization function
to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="LPUART">LPUART</p></td>
        <td align=left><p id="LPUART_WakeUpFromStop2">LPUART_WakeUpFromStop2</p></td>
        <td align=left>  
This example shows how to configure GPIO and LPUART peripherals to allow characters
received on LPUART RX pin to wake up the MCU from low-power mode. This example is based
on the STM32L4xx LPUART LL API. The peripheral initialization is done using LL unitary
services functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="LPUART_WakeUpFromStop2_Init">LPUART_WakeUpFromStop2_Init</p></td>
        <td align=left>  
This example shows how to configure GPIO and LPUART peripherals to allow characters
received on LPUART RX pin to wake up the MCU from low-power mode. This example is based
on the STM32L4xx LPUART LL API. The peripheral initialization is done using LL 
initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="OPAMP">OPAMP</p></td>
        <td align=left><p id="OPAMP_PGA">OPAMP_PGA</p></td>
        <td align=left>
This example describes how to use a operational amplifier
peripheral in PGA mode (programmable gain amplifier). To test the
OPAMP, a voltage waveform is generated by the DAC and feeds the OPAMP
input. This example is based on the STM32L4xx OPAMP LL API. The peripheral
initialization is done using LL unitary service functions for optimization
purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="OPAMP_PGA_Init">OPAMP_PGA_Init</p></td>
        <td align=left>
This example describes how to use a operational amplifier
peripheral in PGA mode (programmable gain amplifier). To test the
OPAMP, a voltage waveform is generated by the DAC and feeds the OPAMP
input. This example is based on the STM32L4xx OPAMP LL API. The peripheral
initialization is done using LL initialization function to demonstrate
LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="PWR">PWR</p></td>
        <td align=left><p id="PWR_EnterStandbyMode">PWR_EnterStandbyMode</p></td>
        <td align=left>
This example shows how to enter Standby mode and wake up from this mode
using an external reset or a wakeup interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_EnterStopMode">PWR_EnterStopMode</p></td>
        <td align=left>
This example shows how to enter the system in Stop 2 mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_LPRunMode_SRAM1">PWR_LPRunMode_SRAM1</p></td>
        <td align=left>
This example shows how to execute code in Low-power run mode from SRAM1.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_OptimizedRunMode">PWR_OptimizedRunMode</p></td>
        <td align=left>
This example shows how to increase/decrease frequency and VCORE and how to enter/exit
Low-power run mode.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="RCC">RCC</p></td>
        <td align=left><p id="RCC_HWAutoMSICalibration">RCC_HWAutoMSICalibration</p></td>
        <td align=left>
This example demonstrates and explains how to use the MSI clock source hardware
auto-calibration to get an accurate MSI clock using LSE (PLL mode). 
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_OutputSystemClockOnMCO">RCC_OutputSystemClockOnMCO</p></td>
        <td align=left>
This example describes how to configure MCO pin (PA8) to output the system clock. 
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_UseHSEasSystemClock">RCC_UseHSEasSystemClock</p></td>
        <td align=left>
This example describes how to use the RCC LL API to start the HSE and use it as system clock.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RCC_UseHSI_PLLasSystemClock">RCC_UseHSI_PLLasSystemClock</p></td>
        <td align=left>
This example shows how to modify the PLL parameters in run time.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="RNG">RNG</p></td>
        <td align=left><p id="RNG_GenerateRandomNumbers">RNG_GenerateRandomNumbers</p></td>
        <td align=left>
This example shows how to configure the RNG peripheral to generate 32-bit long
random numbers. The peripheral initialization is done using LL unitary service
functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RNG_GenerateRandomNumbers_IT">RNG_GenerateRandomNumbers_IT</p></td>
        <td align=left>
This example shows how to configure the RNG peripheral to generate 32-bit long
random numbers using interrupts. The peripheral initialization is done using LL
unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=7><p id="RTC">RTC</p></td>
        <td align=left><p id="RTC_Alarm">RTC_Alarm</p></td>
        <td align=left>
This example guides you through the different configuration steps by mean of LL API 
to ensure Alarm configuration and generation using the RTC peripheral. The peripheral
initialization is done using LL unitary service functions for optimization purpose
(performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Alarm_Init">RTC_Alarm_Init</p></td>
        <td align=left>
This example guides you through the different configuration steps by mean of LL API 
to ensure Alarm configuration and generation using the RTC peripheral. The peripheral 
initialization is done using LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Calendar">RTC_Calendar</p></td>
        <td align=left>
This example guides you through the different configuration steps by mean of LL API
to configure the RTC calendar. The peripheral initialization done using LL unitary service
functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_ExitStandbyWithWakeUpTimer">RTC_ExitStandbyWithWakeUpTimer</p></td>
        <td align=left>
This example shows how to configure the RTC in order to wake up from Standby mode
using RTC Wakeup Timer. The peripheral initialization is done using LL unitary services
functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_ProgrammingTheWakeUpTimer">RTC_ProgrammingTheWakeUpTimer</p></td>
        <td align=left>
This example shows how to configure the RTC in order to work with the RTC Wakeup 
Timer. The peripheral initialization is done using LL unitary service functions 
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_Tamper">RTC_Tamper</p></td>
        <td align=left>
This example guides you through the different configuration steps by mean of LL API 
to ensure Tamper configuration using the RTC peripheral. The peripheral initialization 
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="RTC_TimeStamp">RTC_TimeStamp</p></td>
        <td align=left>
This example guides you through the different configuration steps by mean of LL API 
to ensure Timestamp configuration using the RTC peripheral. The peripheral initialization 
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="SPI">SPI</p></td>
        <td align=left><p id="SPI_OneBoard_HalfDuplex_DMA">SPI_OneBoard_HalfDuplex_DMA</p></td>
        <td align=left>
This example shows how to configure GPIO and SPI peripherals to transmit
bytes from an SPI Master device to an SPI Slave device in DMA mode. The example
is based on the STM32L4xx SPI LL API. The peripheral initialization is done using 
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_OneBoard_HalfDuplex_DMA_Init">SPI_OneBoard_HalfDuplex_DMA_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and SPI peripherals to transmit
bytes from an SPI Master device to an SPI Slave device in DMA mode. The example
is based on the STM32L4xx SPI LL API. The peripheral initialization is done using
LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_OneBoard_HalfDuplex_IT">SPI_OneBoard_HalfDuplex_IT</p></td>
        <td align=left>
This example shows how to configure GPIO and SPI peripherals to transmit bytes
from an SPI Master device to an SPI Slave device in Interrupt mode. The example
is based on the STM32L4xx SPI LL API. The peripheral initialization is done using
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_TwoBoards_FullDuplex_DMA">SPI_TwoBoards_FullDuplex_DMA</p></td>
        <td align=left>
This example shows how to ensure SPI data buffer transmission and reception in
DMA mode. The example is based on the STM32L4xx SPI LL API. The peripheral initialization
is done using LL unitary service functions for optimization purpose
(performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_TwoBoards_FullDuplex_IT">SPI_TwoBoards_FullDuplex_IT</p></td>
        <td align=left>
This example shows how to ensure SPI Data buffer transmission and reception in
Interrupt mode. The example is based on the STM32L4xx SPI LL API. The peripheral
initialization is done using LL unitary service functions for optimization purpose
(performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="SWPMI">SWPMI</p></td>
        <td align=left><p id="SWPMI_Loopback_MultiSWBuffer">SWPMI_Loopback_MultiSWBuffer</p></td>
        <td align=left>
This example describes how to configure the SWPMI peripheral to start a communication
using DMA multibuffers in Loopback mode. The peripheral initialization is done using
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SWPMI_Loopback_MultiSWBuffer_Init">SWPMI_Loopback_MultiSWBuffer_Init</p></td>
        <td align=left>
This example describes how to configure the SWPMI peripheral to start a communication
using DMA multibuffers in Loopback mode. The peripheral initialization is done using
LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SWPMI_Loopback_NoSWBuffer">SWPMI_Loopback_NoSWBuffer</p></td>
        <td align=left>
This example describes how to configure the SWPMI peripheral to start a communication
using No software buffer mode in Loopback mode. The peripheral initialization is done using
LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=8><p id="TIM">TIM</p></td>
        <td align=left><p id="TIM_BreakAndDeadtime">TIM_BreakAndDeadtime</p></td>
        <td align=left>
This example shows how to configure the TIM peripheral to perform the following:
   generate three center-aligned PWM and complementary PWM signals
   insert a defined dead time value
   use the break feature
   lock the desired parameters
This example is based on the STM32L4xx TIM LL API. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance
and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_DMA">TIM_DMA</p></td>
        <td align=left>
This example provides a description of how to use DMA with TIMER update request
to transfer Data from memory to TIMER Capture Compare Register 3 (TIMx_CCR3); 
Example using the STM32L4xx TIM LL API, 
peripheral initialization done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_InputCapture">TIM_InputCapture</p></td>
        <td align=left>
This example shows how to use the TIM peripheral to measure the frequency of
a periodic signal provided either by an external signal generator or by
another timer instance; 
Example using the STM32L4xx TIM LL API, 
peripheral initialization done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OnePulse">TIM_OnePulse</p></td>
        <td align=left>
This example shows how to configure a timer to generate a positive pulse in
Output Compare mode with a length of tPULSE and after a delay of tDELAY;
This example is based on the STM32L4xx TIM LL API; peripheral initialization is done
using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_OutputCompare">TIM_OutputCompare</p></td>
        <td align=left>
This example shows how to configure the TIM peripheral to generate an output 
waveform in different output compare modes;
Example using the STM32L4xx TIM LL API, 
peripheral initialization done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_PWMOutput">TIM_PWMOutput</p></td>
        <td align=left>
This example describes how to use a timer peripheral to generate a 
PWM output signal and update PWM duty cycle; 
Example using the STM32L4xx TIM LL API, 
peripheral initialization done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_PWMOutput_Init">TIM_PWMOutput_Init</p></td>
        <td align=left>
This example describes how to use a timer peripheral to generate a 
PWM output signal and update PWM duty cycle. This example is based on the 
STM32L4xx TIM LL API. The peripheral initialization is done 
using LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="TIM_TimeBase">TIM_TimeBase</p></td>
        <td align=left>
This example shows how to configure the TIM peripheral to generate a time base; 
Example using the STM32L4xx TIM LL API, 
peripheral initialization done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=10><p id="USART">USART</p></td>
        <td align=left><p id="USART_Communication_Rx_IT">USART_Communication_Rx_IT</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral for receiving characters
from HyperTerminal (PC) in Asynchronous mode using Interrupt mode. The peripheral initialization is
done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Communication_Rx_IT_Continuous">USART_Communication_Rx_IT_Continuous</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral for continuously receiving characters
from HyperTerminal (PC) in Asynchronous mode using Interrupt mode. The peripheral initialization is 
done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Communication_Rx_IT_Init">USART_Communication_Rx_IT_Init</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral for receiving characters
from HyperTerminal (PC) in Asynchronous mode using Interrupt mode. The peripheral initialization is done
using LL initialization function to demonstrate LL init usage.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Communication_Tx">USART_Communication_Tx</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripherals to send characters 
asynchronously to an HyperTerminal (PC) in Polling mode. If the transfer could not
be completed within the allocated time, a timeout allows to exit from the sequence
with a Timeout error code. This example is based on STM32L4xx USART LL API. The peripheral
initialization is done using LL unitary service functions for optimization purpose
(performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Communication_TxRx_DMA">USART_Communication_TxRx_DMA</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral
to send characters asynchronously to/from an HyperTerminal (PC) in
DMA mode. This example is based on STM32L4xx USART LL API. The peripheral
initialization is done using LL unitary service functions for optimization
purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_Communication_Tx_IT">USART_Communication_Tx_IT</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral to send characters
asynchronously to HyperTerminal (PC) in Interrupt mode. This example is based on
STM32L4xx USART LL API. The peripheral initialization is done using LL unitary services
functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_HardwareFlowControl">USART_HardwareFlowControl</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripheral
to receive characters asynchronously from HyperTerminal (PC) in Interrupt mode
with Hardware Flow Control feature enabled. This example is based on STM32L4xx
USART LL API. The peripheral initialization is done using LL unitary service functions
for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_SyncCommunication_FullDuplex_DMA">USART_SyncCommunication_FullDuplex_DMA</p></td>
        <td align=left>
This example shows how to configure GPIO, USART, DMA and SPI peripherals to transmit
bytes from/to a USART peripheral to/from a SPI peripheral (in slave mode) by using DMA
mode through the STM32L4xx USART LL API. The peripheral initialization is
done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_SyncCommunication_FullDuplex_IT">USART_SyncCommunication_FullDuplex_IT</p></td>
        <td align=left>
This example shows how to configure GPIO, USART, DMA and SPI peripherals to transmit
bytes from/to a USART peripheral to/from a SPI peripheral (in slave mode) by using Interrupt
mode through the STM32L4xx USART LL API (the SPI uses the DMA to receive/transmit
characters sent from/received by the USART). The peripheral initialization is
done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="USART_WakeUpFromStop1">USART_WakeUpFromStop1</p></td>
        <td align=left>
This example shows how to configure GPIO and USART peripherals
to receive characters on USART RX pin and wake up the MCU from low-power mode,
using STM32L4xx USART LL API. The peripheral initialization is done 
using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="UTILS">UTILS</p></td>
        <td align=left><p id="UTILS_ConfigureSystemClock">UTILS_ConfigureSystemClock</p></td>
        <td align=left>
This example describes how to use UTILS LL API to configure the system clock using PLL with HSI as source
clock. The user application just needs to calculate PLL parameters using STM32CubeMX and call the UTILS LL
API.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UTILS_ReadDeviceInfo">UTILS_ReadDeviceInfo</p></td>
        <td align=left>
This example describes how to read UID, Device ID and Revision ID and save 
them into a global information buffer.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="WWDG">WWDG</p></td>
        <td align=left><p id="WWDG_RefreshUntilUserEvent">WWDG_RefreshUntilUserEvent</p></td>
        <td align=left>
This example describes how to configure the WWDG, periodically update the counter,
and generate an MCU WWDG reset when a user button is pressed. The peripheral initialization
is done using LL unitary service functions for optimization purpose (performance and size).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of examples_ll: 186</b></td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>94</td>
        <td>0</td>
        <td>91</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=15><p id="Examples_MIX">Examples_MIX</p></td>
        <td align=left rowspan=1><p id="ADC">ADC</p></td>
        <td align=left><p id="ADC_SingleConversion_TriggerSW_IT">ADC_SingleConversion_TriggerSW_IT</p></td>
        <td align=left>
This example describes how to use the ADC to perform a single ADC channel
conversion, at each software start. This example uses the interrupt programming
model (for programming models in Polling or DMA mode, refer to other
examples). This example is based on the STM32L4xx ADC HAL and LL API
(LL API usage for performance improvement).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="CRC">CRC</p></td>
        <td align=left><p id="CRC_PolynomialUpdate">CRC_PolynomialUpdate</p></td>
        <td align=left>
This example provides a description of how to use the CRC peripheral
through the STM32L4xx CRC HAL and LL API. The LL API is used for performance
improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="DMA">DMA</p></td>
        <td align=left><p id="DMA_FLASHToRAM">DMA_FLASHToRAM</p></td>
        <td align=left>
This example provides a description of how to use a DMA to transfer 
a word data buffer from Flash memory to embedded SRAM through 
the STM32L4xx DMA HAL and LL API. The LL API is used for performance
improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="DMA2D">DMA2D</p></td>
        <td align=left><p id="DMA2D_MemToMemWithLCD">DMA2D_MemToMemWithLCD</p></td>
        <td align=left>
  This example provides a description of how to configure the DMA2D peripheral in 
  Memory_to_Memory transfer mode and display the result on LCD, in resorting to
  DMA2D LL APIs for performance improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="DMA2D_MemToMemWithRBSwap">DMA2D_MemToMemWithRBSwap</p></td>
        <td align=left>
  This example provides a description of how to configure DMA2D peripheral in 
  Memory to Memory transfer mode with Pixel Format Conversion and images blending 
  then display the result on LCD, in resorting to DMA2D LL APIs for performance improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="I2C">I2C</p></td>
        <td align=left><p id="I2C_OneBoard_ComSlave7_10bits_IT">I2C_OneBoard_ComSlave7_10bits_IT</p></td>
        <td align=left>
This example describes how to perform I2C data buffer transmission/reception between
one master and 2 slaves with different address sizes (7-bit or 10-bit). This example
uses the STM32L4xx I2C HAL and LL API (LL API usage for performance improvement)
and an interrupt.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="OPAMP">OPAMP</p></td>
        <td align=left><p id="OPAMP_CALIBRATION">OPAMP_CALIBRATION</p></td>
        <td align=left>
This example describes how to use an operational amplifier peripheral with OPAMP
calibration and operation. This example is based on the STM32L4xx OPAMP HAL and LL API
(LL API used for performance improvement).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="PWR">PWR</p></td>
        <td align=left><p id="PWR_STANDBY_RTC">PWR_STANDBY_RTC</p></td>
        <td align=left>
This example shows how to enter Standby mode and wake up from this mode using
an external reset or the RTC wakeup timer through the STM32L4xx RTC and RCC HAL
and LL API. The LL API is used for performance improvement.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="PWR_STOP1">PWR_STOP1</p></td>
        <td align=left> 
This example shows how to enter the system in Stop 1 mode and wake up from this
mode using external reset or wakeup interrupt (all the RCC functions calls use 
RCC LL API for footprint and performance improvements).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="SPI">SPI</p></td>
        <td align=left><p id="SPI_FullDuplex_ComPolling">SPI_FullDuplex_ComPolling</p></td>
        <td align=left>
This example shows how to ensure SPI data buffer transmission/reception in Polling 
mode between two boards.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="SPI_HalfDuplex_ComPollingIT">SPI_HalfDuplex_ComPollingIT</p></td>
        <td align=left>
This example shows how to ensure SPI data buffer transmission/reception between 
two boards by using Polling (LL Driver) an interrupt mode (HAL Driver).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="TIM">TIM</p></td>
        <td align=left><p id="TIM_6Steps">TIM_6Steps</p></td>
        <td align=left>
This example shows how to configure the TIM1 peripheral to generate 6 Steps PWM
signal. The STM32L4xx TIM1 peripheral allows programming in advance the configuration
for the next TIM1 output behavior (or step) and changing the configuration of all the
channels simultaneously. This operation is possible when the COM (commutation) event
is used. This example is based on the STM32L4xx TIM HAL and LL API (LL API usage for
performance improvement).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="UART">UART</p></td>
        <td align=left><p id="UART_HyperTerminal_IT">UART_HyperTerminal_IT</p></td>
        <td align=left>
This example describes how to use an UART to transmit data (transmit/receive)
between a board and an HyperTerminal PC application in Interrupt mode. This example
provides a description of how to use USART peripheral through the STM32L4xx UART HAL
and LL API (LL API usage for performance improvement).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="UART_HyperTerminal_TxPolling_RxIT">UART_HyperTerminal_TxPolling_RxIT</p></td>
        <td align=left>
This example describes how to use an UART to transmit data (transmit/receive)
between a board and an HyperTerminal PC application both in Polling and Interrupt
modes. This example provides a description of how to use USART peripheral through
the STM32L4xx UART HAL and LL API (LL API usage for performance improvement).
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of examples_mix: 24</b></td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>10</td>
        <td>0</td>
        <td>12</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>2</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=43><p id="Applications">Applications</p></td>
        <td align=left rowspan=1><p id="-">-</p></td>
        <td align=left><p id="Proximity">Proximity</p></td>
        <td align=left>
This application shows how to use the VL53L0X sensor mounted on the B-L475E-IOT01A 
board to provide proximity information.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="BLE">BLE</p></td>
        <td align=left><p id="HeartRate">HeartRate</p></td>
        <td align=left>
This application shows how to use BLE component for HeartRate profile application.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="P2P_LedButton">P2P_LedButton</p></td>
        <td align=left>
This example aims at demonstrating point-to-point communications using the BLE component.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=5><p id="FatFs">FatFs</p></td>
        <td align=left><p id="FatFs_RAMDisk">FatFs_RAMDisk</p></td>
        <td align=left>
This application provides a description on how to use STM32Cube firmware with FatFs
middleware component as a generic FAT file system module. The objective is to
develop an application that exploits the FatFs features to configure a RAM disk
(SRAM) drive.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FatFs_USBDisk_Standalone">FatFs_USBDisk_Standalone</p></td>
        <td align=left>
This application provides a description on how to use STM32Cube firmware with FatFs 
middleware component as a generic FAT file system module and STM32 USB On-The-Go
(OTG) host library, in  Full Speed (FS) mode
in order to develop an application exploiting FatFs offered features with USB disk drive configuration.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FatFs_uSD_DMA_RTOS">FatFs_uSD_DMA_RTOS</p></td>
        <td align=left>
This application provides a description on how to use STM32Cube firmware with FatFs
middleware component as a generic FAT file system module, in order to develop an
application exploiting FatFs offered features with microSD drive in RTOS mode
configuration.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="FatFs_uSD_DMA_Standalone">FatFs_uSD_DMA_Standalone</p></td>
        <td align=left>
This application provides a description on how to use STM32Cube firmware with FatFs
middleware component as a generic FAT file system module. The objective is to develop an
application making the most of the features offered by FatFs to configure a microSD drive.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FatFs_uSD_Standalone">FatFs_uSD_Standalone</p></td>
        <td align=left>
This application provides a description on how to use STM32Cube firmware with FatFs
middleware component as a generic FAT file system module. The objective is to
develop an application that exploits the FatFs features to configure a microSD drive.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=12><p id="FreeRTOS">FreeRTOS</p></td>
        <td align=left><p id="FreeRTOS_LowPower">FreeRTOS_LowPower</p></td>
        <td align=left>
This application shows how to enter and exit low power mode with CMSIS RTOS API.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_LowPower_LPTIM">FreeRTOS_LowPower_LPTIM</p></td>
        <td align=left>
This application aims to enter MCU in the Stop mode when all RTOS tasks are suspended.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_MPU">FreeRTOS_MPU</p></td>
        <td align=left>
How to use the MPU feature of FreeRTOS.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=red>New</font></td>
        <td><font size="5" color=red>New</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Mail">FreeRTOS_Mail</p></td>
        <td align=left>
This application shows how to use mail queues with CMSIS RTOS API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Mutexes">FreeRTOS_Mutexes</p></td>
        <td align=left>
This application shows how to use mutexes with CMSIS RTOS API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Queues">FreeRTOS_Queues</p></td>
        <td align=left>
This application shows how to use message queues with CMSIS RTOS API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Semaphore">FreeRTOS_Semaphore</p></td>
        <td align=left>
This application shows how to use semaphores with CMSIS RTOS API .
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_SemaphoreFromISR">FreeRTOS_SemaphoreFromISR</p></td>
        <td align=left>
This application shows how to use semaphore from ISR with CMSIS RTOS API .
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Signal">FreeRTOS_Signal</p></td>
        <td align=left>
This application shows how to perform thread signaling using CMSIS RTOS API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_SignalFromISR">FreeRTOS_SignalFromISR</p></td>
        <td align=left>
This application shows how to perform thread signaling from an interrupt using CMSIS RTOS API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_ThreadCreation">FreeRTOS_ThreadCreation</p></td>
        <td align=left>
This application shows how to implement thread creation using CMSIS RTOS API. 
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="FreeRTOS_Timers">FreeRTOS_Timers</p></td>
        <td align=left>
This application shows how to use timers of CMSIS RTOS API.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="IAP">IAP</p></td>
        <td align=left><p id="IAP_Binary_Template">IAP_Binary_Template</p></td>
        <td align=left>
This directory contains a set of sources files that build the application to be
loaded into Flash memory using In-Application Programming (IAP) through USART.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="IAP_Main">IAP_Main</p></td>
        <td align=left>
This directory contains a set of sources files and pre-configured projects that 
describes how to build an application to be loaded into Flash memory using
In-Application Programming (IAP) through USART.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="NFC">NFC</p></td>
        <td align=left><p id="WrAARtoRunBLEapp">WrAARtoRunBLEapp</p></td>
        <td align=left>
This application aims at showing how to write an AAR NDEF message to an M24SR type 4 NFC tag 
so that the BLE STM32 Profiles application is launched on the smartphone when it comes near the 
NFC antenna .
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="WriteTag">WriteTag</p></td>
        <td align=left>
This application aims at showing how to write NDEF messages to an M24SR type 4 NFC tag 
so that the associated application is launched on the smartphone when it comes near the NFC antenna.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=3><p id="STemWin">STemWin</p></td>
        <td align=left><p id="HelloWorld">HelloWorld</p></td>
        <td align=left>
This application contains a set of source files that implement a simple "Hello
World" application based on STemWin.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="STemWin_HelloWorld">STemWin_HelloWorld</p></td>
        <td align=left>
This application shows how to implement a simple "Hello World" example based on STemWin.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="STemWin_SampleDemo">STemWin_SampleDemo</p></td>
        <td align=left>
This application shows how to implement a sample demonstration example allowing 
to show some of the STemWin Library capabilities.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="SubGhz">SubGhz</p></td>
        <td align=left><p id="P2P">P2P</p></td>
        <td align=left>
  This application aims at demonstrating point-to-point communication between two
  B-L475E-IOT01A boards with SubGhz module using Spirit1 driver and STM32Cube firmware. 
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=1><p id="TouchSensing">TouchSensing</p></td>
        <td align=left><p id="TouchSensing_1touchkey">TouchSensing_1touchkey</p></td>
        <td align=left>
This firmware is a basic application on how to use the STMTouch driver with 1 touchkey
sensor. The Environment Change System (ECS) and Detection Time Out (DTO) are also used.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=7><p id="USB_Device">USB_Device</p></td>
        <td align=left><p id="CDC_Standalone">CDC_Standalone</p></td>
        <td align=left>
This example describes how to use USB device application based on the Device 
Communication Class (CDC) following the PSTN subprotocol on the STM32L4xx devices.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="CustomHID_Standalone">CustomHID_Standalone</p></td>
        <td align=left>
This example describes how to use USB device application based on the Custom HID Class on the STM32L4xx devices.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="DFU_Standalone">DFU_Standalone</p></td>
        <td align=left>
This example describes how to use USB device application based on the Device Firmware Upgrade (DFU) on the STM32L4xx devices.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="HID_Standalone">HID_Standalone</p></td>
        <td align=left>
This example describes how to use USB device application based on the Human Interface (HID) on the STM32L4R9I devices.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="HID_Standalone_BCD">HID_Standalone_BCD</p></td>
        <td align=left>
This example describes how to use the BCD feature based on the USB HID device application on the STM32L4xx devices.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="HID_Standalone_LPM">HID_Standalone_LPM</p></td>
        <td align=left>
This example describes how to use USB device application based on the Human Interface (HID) with 
Link Power Management Protocol (LPM) on the STM32L4xx devices.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="MSC_Standalone">MSC_Standalone</p></td>
        <td align=left>
This example describes how to use USB device application based on the Mass Storage Class (MSC) on the STM32L4xx devices.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=4><p id="USB_Host">USB_Host</p></td>
        <td align=left><p id="CDC_Standalone">CDC_Standalone</p></td>
        <td align=left>
This application is a part of the USB Host Library package using STM32Cube firmware. It describes how to use
USB host application based on the Communication Class (CDC) on the STM32L4xx devices.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="HID_Standalone">HID_Standalone</p></td>
        <td align=left>
This example describes how to use USB host application based on the Humain Interface Class (HID) on the STM32L4xx devices.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="MSC">MSC</p></td>
        <td align=left>
This example describes how to use USB host application based on the Mass Storage Class (MSC) on the STM32L4xx devices.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MSC_Standalone">MSC_Standalone</p></td>
        <td align=left>
This example describes how to use USB host application based on the Mass Storage Class (MSC) on the STM32L4xx devices.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="WiFi">WiFi</p></td>
        <td align=left><p id="WiFi_Client_Server">WiFi_Client_Server</p></td>
        <td align=left>
This application shows how to use the Es-WiFi module to perform a TCP client mode
using STM32Cube HAL. It demonstrates how to set up a client program and connect it 
to a TCP server.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="WiFi_HTTP_Server">WiFi_HTTP_Server</p></td>
        <td align=left>
This application shows how to make HTTP requests using the Es-WiFi module based 
on STM32Cube HAL. 
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of applications: 110</b></td>
        <td>0</td>
        <td>5</td>
        <td>28</td>
        <td>5</td>
        <td>15</td>
        <td>5</td>
        <td>11</td>
        <td>10</td>
        <td>0</td>
        <td>2</td>
        <td>12</td>
        <td>0</td>
        <td>0</td>
        <td>6</td>
        <td>11</td>
      </tr>
      <tr align=center>
        <td style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" rowspan=8><p id="Demonstrations">Demonstrations</p></td>
        <td align=left rowspan=5><p id="-">-</p></td>
        <td align=left><p id="Adafruit_LCD_1_8_SD_Joystick">Adafruit_LCD_1_8_SD_Joystick</p></td>
        <td align=left>
This demonstration firmware is based on STM32Cube. It helps you to discover STM32
Cortex-M devices that can be plugged on a STM32 Nucleo board.
</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="Demo">Demo</p></td>
        <td align=left>
The STM32Cube demonstration platform comes on top of the STM32CubeTM as a firmware
package that offers a full set of software components based on a modular architecture.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
      </tr>
      <tr align=center>
        <td align=left><p id="Gravitech_4digits">Gravitech_4digits</p></td>
        <td align=left>
This demonstration firmware is based on STM32Cube. It helps you to discover STM32
Cortex-M devices that can be plugged on a STM32 Nucleo-32 board.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MB1144">MB1144</p></td>
        <td align=left>
The STM32Cube demonstration platform comes on top of the STM32Cube as a
firmware package that offers a full set of software components based on a modular
architecture. All modules can be reused separately in standalone applications. All 
these modules are managed by the STM32Cube demonstration kernel that allows to 
dynamically add new modules and access common resources (storage, graphical components 
and widgets, memory management, real-time operating system). The STM32Cube demonstration
platform is built around the powerful graphical STemWin library and the FreeRTOS realtime
operating system. It uses almost all STM32 features and offers a large scope of use cases
based on the STM32Cube HAL BSP and several middleware components.
</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MenuLauncher">MenuLauncher</p></td>
        <td align=left>
The STM32Cube demonstration platform comes on top of the STM32CubeTM as a firmware
package that offers a full set of software components based on a modular architecture.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left rowspan=2><p id="MenuLauncher">MenuLauncher</p></td>
        <td align=left><p id="MB1314">MB1314</p></td>
        <td align=left>
The STM32Cube demonstration platform comes on top of the STM32Cube(TM) as a firmware
package that offers a full set of software components based on a modular architecture.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr align=center>
        <td align=left><p id="MB1315">MB1315</p></td>
        <td align=left>
The STM32Cube demonstration platform comes on top of the STM32Cube(TM) as a firmware
package that offers a full set of software components based on a modular architecture.
</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td><font size="5" color=green>X</font></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
        <td colspan="3"><b>Total number of demonstrations: 11</b></td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
      </tr>
      <tr style="background-repeat: no-repeat;background-position: right center;background-color: #39A9DC;color: #FFF;" align=center>
      	<td colspan="4"><b>Total number of projects: 931</b></td>
      	<td>5</td>
      	<td>58</td>
      	<td>118</td>
      	<td>70</td>
      	<td>100</td>
      	<td>25</td>
      	<td>14</td>
      	<td>214</td>
      	<td>5</td>
      	<td>178</td>
      	<td>70</td>
      	<td>5</td>
      	<td>5</td>
      	<td>25</td>
      	<td>39</td>
      </tr>
    </table>
  </body>
</html>
